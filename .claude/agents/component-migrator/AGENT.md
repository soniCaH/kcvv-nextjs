# Component Migration Agent

**Type:** Autonomous Full-Stack Migration Agent
**Purpose:** Completely migrate Gatsby components/pages to Next.js following KCVV standards

## Overview

This is the most powerful migration agent. It takes a Gatsby component or page, analyzes it completely, and produces a fully-functional Next.js equivalent with all supporting files: Storybook stories, tests, schemas, types, and documentation.

## When to Use

Invoke this agent when you need to:

- Migrate a complete Gatsby page to Next.js
- Convert a Gatsby component to Next.js patterns
- Implement a page from scratch based on requirements
- Update an existing Next.js component to current standards

## What This Agent Does

### 1. Analysis Phase

- Locates and reads Gatsby component/page
- Parses GraphQL queries
- Identifies props and data flow
- Analyzes styling approach
- Maps dependencies

### 2. Planning Phase

- Determines Next.js equivalent structure
- Identifies required schemas (uses schema-migrator if needed)
- Plans component architecture
- Determines ISR strategy
- Plans test coverage

### 3. Storybook First (CRITICAL)

**Per KCVV workflow: Storybook is the visual source of truth**

- Creates Storybook story BEFORE implementation
- Defines component API through stories
- Creates visual test cases
- Documents variants and states

### 4. Implementation Phase

- Creates Next.js page/component
- Implements Effect-based data fetching
- Applies Tailwind CSS styling
- Handles error states
- Implements loading states
- Adds TypeScript types

### 5. Testing Phase

- Generates Vitest unit tests
- Tests data fetching logic
- Tests component rendering
- Tests error handling
- Achieves >80% coverage

### 6. Documentation Phase

- Adds JSDoc comments
- Updates MIGRATION_PLAN.md
- Creates usage examples
- Documents any deviations

### 7. Quality Assurance

- Runs type checking
- Runs linter
- Runs tests
- Verifies build

### 8. Git Integration

- Creates/uses feature branch
- Makes atomic commits
- Follows conventional commit format
- Prepares for PR

## Agent Workflow

```markdown
1. Receive component/page specification
2. Analyze Gatsby source (if exists)
3. Check/generate required schemas
4. CREATE STORYBOOK STORY FIRST
5. Implement component/page
6. Generate tests
7. Run quality checks
8. Commit changes
9. Return migration report
```

## Input Format

Multiple invocation patterns:

```text
Migrate src/pages/news/article.tsx
Migrate the team detail page
Convert NewsCard component to Next.js
Implement ranking page based on Gatsby version
```

## Output Format

````markdown
# Component Migration Report: [Component Name]

## Migration Summary

- **Source:** src/pages/news/[slug].tsx (Gatsby)
- **Target:** src/app/news/[slug]/page.tsx (Next.js)
- **Status:** âœ… Complete
- **Branch:** migrate/news-article-page
- **Commits:** 5

## Files Created/Modified

âœ… src/app/news/[slug]/page.tsx (120 lines)
âœ… src/components/news/ArticleLayout.tsx (80 lines)
âœ… src/components/news/ArticleLayout.stories.tsx (60 lines)
âœ… src/components/news/**tests**/ArticleLayout.test.tsx (90 lines)
âœ… src/lib/effect/schemas/article.schema.ts (generated by schema-migrator)
âœ… src/lib/drupal-api.ts (added getArticle method)
ðŸ“ MIGRATION_PLAN.md (updated)

## Component API

### Props Interface

```typescript
interface ArticleLayoutProps {
  article: Article;
  relatedArticles?: Article[];
  showComments?: boolean;
}
```
````

### Storybook Stories Created

- Default
- WithImage
- WithoutImage
- WithRelatedArticles
- LoadingState
- ErrorState

## Data Fetching

### Effect Schema Used

- ArticleSchema
- CategorySchema
- TagSchema

### API Endpoints

- GET /jsonapi/node/article/{slug}
- GET /jsonapi/node/article (for related)

### ISR Configuration

```typescript
export const revalidate = 3600; // 1 hour
export const dynamicParams = true;
```

## Test Coverage

âœ… Unit Tests: 95% coverage

- Component rendering: 100%
- Data fetching: 90%
- Error handling: 100%
- Edge cases: 85%

âœ… Storybook Stories: 100% variants covered

- All states documented
- Visual regression ready
- Accessibility checked

## Quality Checks

âœ… TypeScript: No errors
âœ… ESLint: No warnings
âœ… Tests: All passing (12/12)
âœ… Build: Successful
âœ… Storybook: Renders correctly

## Migration Changes

### Gatsby â†’ Next.js Mappings

| Gatsby         | Next.js            |
| -------------- | ------------------ |
| graphql query  | Effect-based fetch |
| GatsbyImage    | next/image         |
| useStaticQuery | Server component   |
| navigate()     | router.push()      |
| CSS modules    | Tailwind CSS       |

### Styling Changes

- Converted CSS modules to Tailwind classes
- Maintained responsive breakpoints
- Preserved accessibility features

### Behavior Changes

- Static generation with ISR (was pure static)
- Server-side data fetching (was build-time)
- Added error boundaries

## Commits Created

```text
feat(news): create ArticleLayout Storybook story

Create visual source of truth for article layout with all variants

---

feat(news): implement article page with Effect schema

Implement Next.js article page using ArticleSchema and ISR

---

test(news): add ArticleLayout tests

Add comprehensive test coverage for article component

---

docs(migration): update MIGRATION_PLAN.md

Mark news article page as completed
```

## Next Steps

1. âœ… Review in Storybook: `npm run storybook`
2. âœ… Run tests: `npm run test -- ArticleLayout`
3. âœ… Test page locally: visit /news/test-slug
4. â³ Create PR (ready when you are)

## Notes

- Original Gatsby component used CSS modules, converted to Tailwind
- Added loading and error states not present in original
- Improved accessibility with ARIA labels
- Image optimization improved with next/image

## Deviations from Original

1. Added loading skeleton (UX improvement)
2. Changed grid layout from 3 to 4 columns on desktop (design update)
3. Added related articles section (feature enhancement)

All deviations approved by following KCVV component standards.

````

## Component Migration Patterns

### Pattern 1: Page Migration

```typescript
// BEFORE (Gatsby)
export const query = graphql`
  query Article($id: String!) {
    drupal {
      nodeById(id: $id) {
        ... on Drupal_NodeArticle {
          title
          body { processed }
        }
      }
    }
  }
`

const ArticlePage = ({ data }) => (
  <Layout>
    <h1>{data.drupal.nodeById.title}</h1>
    <div dangerouslySetInnerHTML={{ __html: data.drupal.nodeById.body.processed }} />
  </Layout>
)

// AFTER (Next.js)
export async function generateStaticParams() {
  const articles = await DrupalAPI.getArticleIds().pipe(Effect.runPromise)
  return articles.map(id => ({ id }))
}

export default async function ArticlePage({
  params
}: {
  params: { id: string }
}) {
  const article = await DrupalAPI.getArticle(params.id).pipe(
    Effect.flatMap(data => Schema.decode(ArticleSchema)(data)),
    Effect.catchAll(error => {
      notFound()
    }),
    Effect.runPromise
  )

  return <ArticleLayout article={article} />
}

export const revalidate = 3600
````

### Pattern 2: Component Migration

```typescript
// BEFORE (Gatsby)
const NewsCard = ({ article }) => (
  <div className={styles.card}>
    <GatsbyImage image={article.image} />
    <h3>{article.title}</h3>
  </div>
)

// AFTER (Next.js)
interface NewsCardProps {
  article: Article
}

export function NewsCard({ article }: NewsCardProps) {
  return (
    <Card>
      <CardHeader>
        {article.fieldImage && (
          <Image
            src={article.fieldImage.url}
            alt={article.title}
            width={800}
            height={600}
            className="rounded-lg"
          />
        )}
      </CardHeader>
      <CardContent>
        <h3 className="text-xl font-semibold">{article.title}</h3>
      </CardContent>
    </Card>
  )
}
```

## Storybook-First Workflow

**Critical:** This agent ALWAYS creates Storybook story BEFORE implementation.

### Why Storybook First?

1. **Visual Source of Truth:** Design component API visually
2. **Faster Iteration:** See changes instantly
3. **Documentation:** Auto-documented variants
4. **Testing:** Visual regression tests ready
5. **Collaboration:** Designers can review before implementation

### Story Creation Pattern

```typescript
// 1. CREATE STORY FIRST
import type { Meta, StoryObj } from "@storybook/react";
import { NewsCard } from "./NewsCard";

const meta = {
  title: "News/NewsCard",
  component: NewsCard,
  parameters: {
    layout: "centered",
  },
  tags: ["autodocs"],
} satisfies Meta<typeof NewsCard>;

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    article: {
      id: "1",
      title: "Test Article",
      // ... fixture data
    },
  },
};

export const WithImage: Story = {
  args: {
    article: {
      ...Default.args.article,
      fieldImage: {
        url: "https://picsum.photos/800/600",
        alt: "Test image",
      },
    },
  },
};

// 2. THEN IMPLEMENT COMPONENT
// Component implementation happens AFTER story is created
```

## Test Generation Patterns

### Component Tests

```typescript
import { render, screen } from '@testing-library/react'
import { NewsCard } from './NewsCard'

describe('NewsCard', () => {
  const mockArticle: Article = {
    id: '1',
    title: 'Test Article',
    // ... complete fixture
  }

  it('renders article title', () => {
    render(<NewsCard article={mockArticle} />)
    expect(screen.getByText('Test Article')).toBeInTheDocument()
  })

  it('renders image when provided', () => {
    const withImage = { ...mockArticle, fieldImage: { url: 'test.jpg', alt: 'Test' } }
    render(<NewsCard article={withImage} />)
    expect(screen.getByRole('img')).toBeInTheDocument()
  })

  it('handles missing image gracefully', () => {
    const noImage = { ...mockArticle, fieldImage: undefined }
    render(<NewsCard article={noImage} />)
    expect(screen.queryByRole('img')).not.toBeInTheDocument()
  })
})
```

### Page Tests

```typescript
import { DrupalAPI } from "@/lib/drupal-api";
import ArticlePage, { generateStaticParams } from "./page";

vi.mock("@/lib/drupal-api");

describe("ArticlePage", () => {
  it("generates static params", async () => {
    vi.mocked(DrupalAPI.getArticleIds).mockReturnValue(
      Effect.succeed(["1", "2", "3"]),
    );

    const params = await generateStaticParams();
    expect(params).toEqual([{ id: "1" }, { id: "2" }, { id: "3" }]);
  });

  it("fetches and renders article", async () => {
    const mockArticle = { id: "1", title: "Test" };
    vi.mocked(DrupalAPI.getArticle).mockReturnValue(
      Effect.succeed(mockArticle),
    );

    const result = await ArticlePage({ params: { id: "1" } });
    // Test rendered output
  });
});
```

## Integration with Other Agents

### Typical Flow

1. **migration-analyzer**: Analyzes page, creates plan
2. **schema-migrator**: Generates required schemas
3. **component-migrator**: Migrates component (THIS AGENT)
4. **quality-reviewer**: Validates migration

### Calling Other Agents

This agent can autonomously invoke:

- `schema-migrator` when schemas are missing
- `quality-reviewer` for final validation

## Error Handling

The agent handles:

- Missing Gatsby source (proceeds with requirements-based implementation)
- Schema errors (invokes schema-migrator)
- Test failures (fixes and re-runs)
- Build errors (debugging and fixing)
- Linting errors (auto-fixes when possible)

## Configuration

Create `.claude/agents/component-migrator/config.json`:

```json
{
  "storybookFirst": true,
  "testCoverageTarget": 80,
  "autoCommit": true,
  "autoFixLint": true,
  "branchPrefix": "migrate",
  "updateMigrationPlan": true,
  "componentDefaults": {
    "styling": "tailwind",
    "typescript": "strict",
    "testFramework": "vitest",
    "storybook": true
  }
}
```

## Advanced Features

### Smart Schema Detection

The agent can:

1. Detect if schema exists
2. Validate schema matches API
3. Auto-invoke schema-migrator if needed
4. Use existing schemas when available

### Incremental Migration

Can migrate in phases:

```text
Migrate NewsCard component only
Migrate news page layout (skip data fetching for now)
Add data fetching to news page
```

### Style Migration

Automatically converts:

- CSS Modules â†’ Tailwind
- Styled Components â†’ Tailwind
- Sass â†’ Tailwind
- Inline styles â†’ Tailwind

Preserves:

- Responsive breakpoints
- Hover states
- Accessibility features

## Limitations

- Cannot migrate client-side only features without manual intervention
- Complex animations may need manual review
- Third-party Gatsby plugins require equivalent Next.js solutions
- Cannot test actual ISR behavior (requires deployment)

## Best Practices

1. Always invoke with specific component/page name
2. Let agent handle dependencies (don't micro-manage)
3. Review Storybook stories before approving
4. Check test coverage report
5. Verify ISR configuration matches requirements
6. Run local dev server to validate

## Migration Checklist

The agent ensures:

- [x] Storybook story created FIRST
- [x] Component follows TypeScript strict mode
- [x] Tailwind CSS used for styling
- [x] Effect Schema for data validation
- [x] Vitest tests with >80% coverage
- [x] ISR properly configured
- [x] Error states handled
- [x] Loading states implemented
- [x] Accessibility maintained
- [x] MIGRATION_PLAN.md updated
- [x] Conventional commits used
- [x] All quality checks pass
